@model IEnumerable<TestApp.Models.Contact>

<h2>Contacts</h2>

<input type="text" id="searchInput" placeholder="Search..." class="form-control mb-3">

<table class="table" id="contactsTable">
    <thead>
    <tr>
        <th onclick="sortTable(0, this)">Name <span class="sort-indicator"></span></th>
        <th onclick="sortTable(1, this)">Date of Birth <span class="sort-indicator"></span></th>
        <th onclick="sortTable(2, this)">Married <span class="sort-indicator"></span></th>
        <th onclick="sortTable(3, this)">Phone <span class="sort-indicator"></span></th>
        <th onclick="sortTable(4, this)">Salary <span class="sort-indicator"></span></th>
        <th>Actions</th>
    </tr>
    </thead>
    <tbody>
    </tbody>
</table>

<script>
    const contacts = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model));

    const tableBody = document.querySelector('#contactsTable tbody');

    function renderTable(data) {
        tableBody.innerHTML = '';
        if (data.length === 0) {
            const row = document.createElement('tr');
            row.innerHTML = '<td colspan="6" class="text-center">No contacts available</td>';
            tableBody.appendChild(row);
        } else {
            data.forEach(contact => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td contenteditable="true" data-field="Name">${contact.Name}</td>
                    <td contenteditable="true" data-field="DateOfBirth">${new Date(contact.DateOfBirth).toLocaleDateString()}</td>
                    <td contenteditable="true" data-field="Married">${contact.Married}</td>
                    <td contenteditable="true" data-field="Phone">${contact.Phone}</td>
                    <td contenteditable="true" data-field="Salary">${contact.Salary}</td>
                    <td>
                        <button class="btn btn-primary btn-sm" onclick="saveRow(this, ${contact.Id})">Save</button>
                        <button class="btn btn-danger btn-sm" onclick="deleteRow(${contact.Id})">Delete</button>
                    </td>
                `;
                tableBody.appendChild(row);
            });
        }
    }

    renderTable(contacts);

    document.getElementById('searchInput').addEventListener('keyup', function () {
        const filter = this.value.toLowerCase();
        const filteredContacts = contacts.filter(contact =>
            Object.values(contact).some(value => value.toString().toLowerCase().includes(filter))
        );
        renderTable(filteredContacts);
    });

    function sortTable(columnIndex, headerElement) {
        const isAscending = headerElement.getAttribute('data-sort-order') !== 'asc';
        const sortedContacts = [...contacts].sort((a, b) => {
            const keys = ['Name', 'DateOfBirth', 'Married', 'Phone', 'Salary'];
            const key = keys[columnIndex];

            if (key === 'DateOfBirth') {
                return isAscending ? new Date(a[key]) - new Date(b[key]) : new Date(b[key]) - new Date(a[key]);
            } else if (key === 'Salary') {
                return isAscending ? a[key] - b[key] : b[key] - a[key];
            } else {
                return isAscending ? a[key].toString().localeCompare(b[key].toString()) : b[key].toString().localeCompare(a[key].toString());
            }
        });

        document.querySelectorAll('.sort-indicator').forEach(indicator => indicator.textContent = '');
        headerElement.querySelector('.sort-indicator').textContent = isAscending ? '▲' : '▼';

        headerElement.setAttribute('data-sort-order', isAscending ? 'asc' : 'desc');
        renderTable(sortedContacts);
    }

    async function saveRow(button, contactId) {
        const row = button.closest('tr');
        const updatedContact = { Id: contactId };
        let isValid = true;
        let errorMessage = '';

        row.querySelectorAll('[contenteditable]').forEach(cell => {
            const field = cell.getAttribute('data-field');
            const value = cell.textContent.trim();

            switch (field) {
                case 'Name':
                    if (!value) {
                        isValid = false;
                        errorMessage += 'Name cannot be empty.\n';
                    }
                    updatedContact[field] = value;
                    break;
                case 'DateOfBirth':
                    if (isNaN(Date.parse(value))) {
                        isValid = false;
                        errorMessage += 'Date of Birth must be a valid date.\n';
                    } else {
                        updatedContact[field] = new Date(value).toISOString();
                    }
                    break;
                case 'Married':
                    if (value.toLowerCase() !== 'true' && value.toLowerCase() !== 'false') {
                        isValid = false;
                        errorMessage += 'Married must be either true or false.\n';
                    }
                    updatedContact[field] = value.toLowerCase() === 'true';
                    break;
                case 'Phone':
                    const phoneRegex = /^[0-9]{3}-[0-9]{3}-[0-9]{4}$/;
                    if (!phoneRegex.test(value)) {
                        isValid = false;
                        errorMessage += 'Phone must match the pattern 789-123-4567.\n';
                    }
                    updatedContact[field] = value;
                    break;
                case 'Salary':
                    const salary = parseFloat(value);
                    if (isNaN(salary) || salary < 0) {
                        isValid = false;
                        errorMessage += 'Salary must be a positive number.\n';
                    }
                    updatedContact[field] = salary;
                    break;
                default:
                    updatedContact[field] = value;
            }
        });

        if (!isValid) {
            alert(`Validation failed:\n${errorMessage}`);
            const originalContact = contacts.find(c => c.Id === contactId);
            // Revert fields to original values
            row.querySelectorAll('[contenteditable]').forEach(cell => {
                const field = cell.getAttribute('data-field');
                cell.innerHTML = field === "DateOfBirth" ? (new Date(originalContact[field]).toLocaleDateString()) : originalContact[field];
            });
            return;
        }

        try {
            const response = await fetch('/Doc/UpdateContact', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(updatedContact)
            });

            if (response.ok) {
                alert('Contact updated successfully!');
            } else {
                alert('Failed to update contact.');
            }
        } catch (error) {
            console.error('Error updating contact:', error);
            alert('An error occurred while updating the contact.');
        }
    }

    async function deleteRow(contactId) {
        if (!confirm('Are you sure you want to delete this contact?')) {
            return;
        }

        try {
            const response = await fetch(`/Doc/DeleteContact/${contactId}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                alert('Contact deleted successfully!');
                const index = contacts.findIndex(contact => contact.Id === contactId);
                if (index !== -1) {
                    contacts.splice(index, 1);
                    renderTable(contacts);
                }
            } else {
                alert('Failed to delete contact.');
            }
        } catch (error) {
            console.error('Error deleting contact:', error);
            alert('An error occurred while deleting the contact.');
        }
    }
</script>